# 11 脚本去花指令 & 易语言特征码应用
* 上节课的内容回顾
>1. main函数真的是最早执行的函数吗？(No) 全局变量在哪个函数进行初始化？(\_initterm)
>2. TLS--线程局部存储（为什么常常被用来进行反调试）(先于OEP运行，OD不停在OEP)
>3. 定位TLS的两个方法（插件StrongOD--但是插件在x64功能有限不是全部有效，PE结构--TLS目录AddressOfCallBacks）
>4. 指令变形，能修改EIP的指令，都能够实现花指令
>5. 俩个反调试函数：NtSetInformationThread、NtQueryInformationProcess

* 上节课的作业讲解继续补充某CTF--GIVE_A_TRY
NtQueryInformationProcess函数的第五个参数是`指向变量的指针，其中函数返回所请求信息的大小。 如果函数成功，则这是 _由 ProcessInformation_ 参数指向的缓冲区中写入的信息的大小 (如果缓冲区太小，则为成功接收信息) 所需的最小缓冲区大小。`所以返回是4。但是由于StrongOD有漏洞把返回变成了0，这道题就有利用到这一点。如下图，位置变成0，即使输入正确的注册码也提示不成功：
![[Pasted image 20240126183636.png]]
如果是正常的种子数应该是如下图这样的：
![[Pasted image 20240127114429.png]]
如过被反调试检测修改了这里的值，那就不好逆算法，但是还有一种方式，可以使用CE修改器来读取如下图：CE用好了也是神器，而且这玩意只是读取内存，不会被检测到。
![[Pasted image 20240127120029.png]]


在找到花指令的规则模板之后可以Ctrl+B直接二进制搜索匹配，还支持模糊匹配。类似于这样`E8 01 00 00 00 ?? ?? ?? ?? ?? C3`
当我们找到这样的规律后就可以不用一个个手动去，可以写脚本。
- 使用脚本去除反调试函数的花指令
OD有个运行脚本的插脚叫odbgscript在github上开源可下载。
编写脚本如下：
```
//判断是否找到
cmp $RESULT,0
//如果没找到就跳出结束
je exit
//如果找到就填充成NOP
mov [$RESULT],#90909090909090909090909090909090909090909090909090909090#
//从Eip的位置查找下一个特征码
find eip,#E80000000081042425000000C354686520666C616720626567696E7320776974682022666C61677B2200#


//判断是否找到
cmp $RESULT,0
//没找到就退出
je exit
//找到了就填充为NOP
mov [$RESULT],#909090909090909090909090909090909090909090909090909090909090909090909090909090909090#
//定义一个循环的标签，因为下面这个特征码不止一处，所以需要循环多次进行查找
loop:
	//从Eip的位置查找
	find eip,#E801000000??????????C3#
	//判断是否找到
	cmp $RESULT,0
	//如果找不到了就退出
	je exit
	//找到就填充为90
	mov [$RESULT],#9090909090909090909090#
//继续循环
jmp loop
exit:
MSG "花指令已去除完毕！\r\n Code by:Elven"
ret
```
右键--》运行脚本--》打开
右键--》脚本功能--》脚本运行窗口--》Tab键即可单步执行
更多脚本语法请参阅：ODbgScript中文说明v1.83
#### 易语言特征码应用篇
对付易语言程序最好从00401000开始搜索
1. 字符串比较函数特征码：test edx,3
	注意观察ECX和EDX对比字符串可能会在这里明文显示
		mov edx,dword ptr ss:[esp+0x4]
		mov ecx,dword ptr ss:[esp+0x8]
		test edx,edx
2. 按钮事件特征码：FF55FC5F5E
3. 易语言体特征码：FF25
	可以发现易语言也有类似微软的IAT表，所以也可以在这里全部下断点，肯定会用到的。
	![[Pasted image 20240126220507.png]]
如下图，易语言使用的是VC98linker微软（VC6.0）的链接器，链接器最大的作用是辅助调试，在VS项目的属性中--链接器--所选项可以控制生成的调试信息，当关闭时，OD都是jmp的一堆地址，根本看不懂，当打开OD就是显示符号（函数名）。因此我们可以对这部分链接器做修改，就能使易语言的程序在OD中显示出调试符号（API函数名）（挖坑，以后的内容，甚至在PE结构中也能找）
![[Pasted image 20240126221014.png]]
易语言--》失败点1--用的微软的VC链接器，失败点2--把何核心库的开发文档格式公开了
# 13 深入浅出易语言核心逆向(上)
课程回顾上面的特征码，核心必需要记住
* 先引入探究一下MFC程序的逆向
1. 建立一个MFC程序
2. 分析MFC程序按钮事件调用过程
3. 快速找到按钮点击后的代码位置
>建立时选--基于对话框--在静态库中使用MFC
>消息机制--是针对窗口GUI程序来说的，层层传递然后再到写的代码进行处理

程序拖入OD，运行后点击按钮，再暂停，Alt+K分析调用堆栈，如下图：越靠近上面的越是靠经最近执行的。
分析如下：
调用了AfxWinMain，这是MFC封装的，然后掉用了DoModel这是模态对话框，模式对话框时在对话框弹出后调用函数不会立即返回，而是等到对话框销毁后才会返回。（就弹出一个弹窗后，后面那个窗口就根本点不了了，这是由于UI线程阻塞，最上层弹窗有个死循环，一直等待用户消息）。但是我们附件里写的简单程序是非多模态的，弹框过后后面还能点能拖动。
[深入理解MFC消息循环和消息泵的原理\_mfc !afxgetapp()->pumpmessage()-CSDN博客](https://blog.csdn.net/u011555996/article/details/121755424)
然后应该清楚MFC的消息循环(::GetMessage,::PeekMessage)，消息泵(CWinThread::PumpMessage)和MFC的消息在窗口之间的路由是两件不同的事情。在MFC的应用程序中(应用程序类基于CWinThread继承)，必须要有一个消息循环，他的作用是从应用程序的消息队列中读取消息，并把它派送出去(::DispatchMessage)。而消息路由是指消息派送出去之后，系统(USER32.DLL)把消息投递到哪个窗口，以及以后消息在窗口之间的传递是怎样的。 
然后到user32往上传，遇到Afx的函数就是MFC的函数，AfxWndProc就是MFC接收消息的函数
![[Pasted image 20240128172558.png]]
![[Pasted image 20240128172609.png]]
额，好烦，我的程序OD看调用堆栈看不到和课程一样的流程，分开来了。why?
还好还有种在VS看的方法：执行调试--》调试--》窗口--》调用堆栈
如下图分析：
下面标红和标黄都是我们上面OD提到的并应该显示的。这都是在了解消息传递的概念
其实最重要应该关注的_AfxDispatchCmdMsg，这是因为所有的按钮事件都是会来到这个函数的，必经之路必须记住，是黄色箭头选中的，红框那个函数里面的第四个参数也被标红，它存储的是按钮事件触发后掉用的函数！！！
![[Pasted image 20240128181924.png]]
![[Pasted image 20240128182143.png]]

有了上面的哪些基础概念，就可以来到下一步看，OD,Ctrl+搜索_AfxDispatchCmdMsg，下断点，执行，点击按钮，如下图分析：
观察堆栈，由于函数Cdcol函数调用约定概念，参数从右边往左边压栈，所以第一个参数会在堆栈的第二行，第三行是第二个参数，依次类推，第一行是call指令把下一条返回地址给压栈了。
![[Pasted image 20240128183305.png]]

可以在汇编窗口搜索堆栈的地址，然后输入冒号打标签，就会像下面这张图一样
![[Pasted image 20240128224654.png]]

在_AfxDispatchCmdMsg下断点然后单步执行就会发现下面的call调用了按钮事件，如下图，在VS中就类似断点指向的那一句，下面就会进入到按钮事件的函数。
![[Pasted image 20240129115634.png]]
![[Pasted image 20240129115813.png]]

最后提一下怎么提取特征码呢？？？
>a. 有绝对地址的是绝对不可以当作特征码的，需要用OD的通配符`?`代替
  b. 有call不行，如果一定需要，必须把地址换成通配符
  c. ([0x地址])常量不行，一定要换成通配符

在提取到特征码之后，就可以模拟易语言程序，或者新建一个VS程序，关闭调试符号。直接在Alt+M内存窗口--》右键--》查找--》粘贴特征码(必要位置换成通配符)到Hex--》确定。
最后在数据窗口找到地址，直接在汇编窗口查找该内存地址就可以找到目标函数。当然直接在汇编窗口Ctrl+B速度显然更快。但是在所有的内存窗口搜显然更全面，在汇编窗口Ctrl+B如果是进入了某一个DLL也许会搜不到。这就是一个小细节tips,教程细节呀！

* 易语言程序的逆向
1. 易语言链接器选项
2. 参考MFC程序的逆向方法分析易语言程序
3. 如何提取特征码

在易语言中如何像VS一样可以打开调试符号呢？如下图，这是个冷门知识，没有资料可查，取消前面的分号注释，添加我们的`/DEBUG:FULL`
![[Pasted image 20240129134144.png]]

此时再编译一个易语言程序，然后点击静态编译，弹出缺少链接库一样点否（如果想解决可把VC的动态链接库拷贝到易语言目录下，但是不重要没演示，挖坑下节课演示）一样能编译出来(有好多jmp，我以为是IAT原来是增量链接，如下图，易语言怎么去除增量链接？下面讲)
![[Pasted image 20240129213516.png]]

然后下按钮事件的特征码断点，然后回车call看到关键函数，再如下图看到传入了一个叫.krnln_fnMsgBox的参数给ebx
![[Pasted image 20240129214608.png]]

然后下面接着一个call，继续回车跟踪看，发现有个call直接就call ebx。如下图管观察ebx的值，然后和上图传入的值对比发现一样，而且继续回车call跟踪发现就会,这个函数里面又调用了MessageBoxA所以，得出结论易语言就是这么层层封装的。
![[Pasted image 20240129215114.png]]


总结：别人发布的程序肯定是不会开启调试符号的，这个方法只是适合我们自己去研究一些原理和提取特征码的时候使用。别人几千教学的才不会教你这些原理。只会教一些特征码的使用。而自己研究怎么产生的原理才是真正的逆向！！！
重要：VS生成的.pdb文件,是调试符号文件，给别人程序的时候一定不能给别人，因为逆向人在IDA中--》file-->load file--》pdb file  可以直接加载出函数名，就是调试符号。大大减低了逆向难度。

如果开启了调试符号信息，那么逆向人员在分析在分析时候，IDA直接打开PE文件就会发现弹窗如下图![[Pasted image 20240129141231.png]]

当我们把pdb文件删除，OD打开程序，发现还是有调试符号，结论：调试符号的变量名是在PE文件里面的。而pdb只是在VS中点击调试来辅助调试的。

要去除易语言的增量链接。还是去VS找到关闭增量链接的关键词`/INCREMENTAL:NO`然后还是添加到易语言的配置文件后面。如下图：此时的程序编译后OD就没有增量链接jmp了。
![[Pasted image 20240129145432.png]]

关闭增量链接后程序如下图所示：
![[Pasted image 20240129215715.png]]


课程说pdb文件微软当时暂未公开，但是github上已经有人逆向出来公开了



* 利用时钟扰乱按钮事件断点
1. 条件断点
2. 干掉时钟（不可取）
![[Pasted image 20240129222751.png]]
当编写一个易语言程序的时候，如果下断点在按钮事件特征码是可以断下的，但是如果加了一个时钟，并加上周期，用时钟修改控件的属性，就会断到时钟函数的call，如下图回车跟踪断下的call，因为回车call过去看就会知道了，不断到我们想断的地方。
![[Pasted image 20240129222203.png]]

时钟不是线程！所以有些外挂开发会随机崩，因为另起线程，但是时钟是在主线程执行的，能达到类似效果还不会崩，所以有好多易语言外挂很多时钟。

解决方法是设置条件断点，让  [call的地址]!=0x时钟函数的地址。此时就不会断到时钟call里面，而断在了我们真正想断的地方。
![[Pasted image 20240129222532.png]]
还有一种方法是PCHunter干掉时钟，右键--》查看--》进程定时器--》可以直接右键移除！！！但是在x64系统下不可取，会过一会儿蓝屏了！！！不知道原因，32位没问题

* PSUH窗体是怎么回事
1. 手动实现PUSH窗体
2. 插件的使用
之前我们学习过了到哪卡死到哪停下，回复线程继续，还有易语言体FF 25。回顾完后，实际操作并观察。会发现我们执行到了易语言体附近了，带有调试符号分析。.krnl_MLoadBejinWin就是创建主窗体的API，前面的Push就是他的参数窗体ID，易语言不同于VS，采用的是窗体ID传参不是句柄。如下图
![[Pasted image 20240129152901.png]]


因此我们是否就可以考虑把ID偷换掉呢，换成真正实现功能的ID。哇擦，学到这，我只能感叹呀，思路够骚，什么方法都有呀！！！
下断点到PUSH，然后用插件EWND--》一键获取--》枚举窗口--》即可获得所有点窗口ID，然后我们把PUSH的立即数替换掉就能实现直接显示功能窗口！！！nb(这个插件的作者就是上次那个CTF_GIVE_A_TRY的出题作者！)
后面就可以分析一些语言外挂了，比如飘云阁的，注意一定要在虚拟机里，当心小心被格盘蓝屏！
最后，上面的特征码。是画眉老师提取的特征码，已经公布出来了，学过的人可能都会把它VM掉，所以学完这节课我们需要学会提取自己的特征码！这就可以去实战了！
# 13深入浅出易语言核心逆向（上）
上节课程回顾
1. 通过对MFC按钮事件的分析，知道了如何快速定位MFC程序按钮事件（遗留问题；易语言的还没讲）
2. 易语言链接器选项如何生成调试符号 ，关闭增量链接。(易语言的安装路径`D:\software\e5.9\e\tools`的`link.ini`文件设置`extra_args=/DEBUG:FULL /INCREMENTAL:NO`)
3. 讲解了PDB文件和DEBUG选项之间的关系（调试符号保存在PE文件，pdb辅助调试）
4. 如何提取特征码（绝对地址，call，常量 都要换成通配符）
5. 按钮事件特征码不停地断下，原因以及如何解决（有时钟，给条件断点）
6. 修改窗口ID，实现绕过登陆窗口，直接加载程序主窗口
7. 利用EWND插件PUSH窗体方法破解

1. 什么是环境变量
	>是文件路径
	>设置完之后一定要重新打开cmd才会重新读取生效
2. 易语言生成DEBUG时报错解决。
	>把VC开发工具下的VC98的`MFC\LIB`里面的NAFXCW.PDB和NAFXCW.LIB这两个文件复制并替换到易语言安装路径下的`VC98linker\MFC\Lib`里
3. 易语言按钮事件的特征吗是怎么来的（\_AfxDispatchCmdMsg）
>	模仿MFC程序在易语言程序\_AfxDispatchCmdMsg这里下断点，跟踪它的第四个参数下断点执行到，发现这并不是像MFC一样是按钮事件的函数，而是还层层封装了，这里面只是其中一层封装，一直F7往里面跟踪到第四层，才发现到了易语言的按钮事件特征码存在的函数位置。

编写一个易语言程序，双击主窗口，进入代码编写，设置启动项，给它添加一个启动窗口，继续在按钮事件特征码下断点，F7跟踪会发现，这次来的函数是启动窗口而不是按钮事件哟。
结论：按钮事件特征码（不光是按钮事件）还很多消息控件的必经之地，比如上节课提到的时钟呀！

假设有人知道这个特征了，后在包含按钮事件特征码的位置的整个函数都VM掉了那怎么办呢？

答案：思路不只有一个，比如可以提前自己写个程序，在包含按钮事件特征码的位置的整个函数函数头部下断点执行到，根据堆栈，知道这个函数的返回地址，找到在call这个函数的地方下断点。还有方法2：在包含按钮事件特征码的位置的整个函数内部找到其他的call的内部，下断点，跟踪到retn，那最后也能跟踪返回到包含按钮事件特征码的位置的整个函数！

4. 按钮事件最需要关注的两个东西（一个是启动窗口，按钮点击）
5. 上节课后作业破解演示
	>Ctrl+L 搜索下一个
	>只有在两个字符串在进行比较的时候才能搜索到test edx,3  如果是加入了算法，比较的是整数呢？那就搜不到了。
	>判断是否是易语言写的程序，就看00401000，是xor eax,eax那就是易语言程序
	>E-Debug&Analysis修复版作者--Xjun小俊；EWND作者--by_BaZzi	

使用工具E-Reverse打开运行中的易语言程序进程，选择模块，分析全选打勾，点击程序分析，可以看到输出地址，点击MAP，就会生成.map文件，下一步如下啊
OD插件--GODUP--map载入器--载入标签（注释）--选择刚才写出的MAP文件--》即可看到OD内很多指令都打上了标签或者注释！
![[Pasted image 20240130220154.png]]
这个工具配合插件是什么原理呢，可以看到上面有lib文件夹，里面有个叫`krnln.fne`的文件，这是什么呢？把它拖到CFF,发现好像是dll，其实这就是别人逆出来的易语言核心库（工具--支持库配置）`e/lib`。

最后作业：到https://www.52pojie.cn/forum-22-1.html板块CrackMe

# 14 深入浅出易语言核心逆向(中)--实战篇
像上节课发的工具即使有源码也无法编译出来使用。因为他们以前是使用黑月（现在不干了）编译的。所以可以进行代码审计然后自己尝试写一个出来编译[# 详解C/C++代码的预处理、编译、汇编、链接全过程](https://zhuanlan.zhihu.com/p/618037867)，基础班的作业就是这个。《易语言分析调试工具--可以读取进程列表和分析消息事件》 
* E-debug插件介绍
Xjun(2.0)-->fjqisba(3.x)
 昨天在上面学习了新的工具E-Reverse来给汇编指令打标签，但是步骤略微的多点麻烦。其实还有更多的好用的工具，比如`E-Debug2.0--小俊`
 有个大学生github叫fjqisba升级了这个`E-Debug3.0`但是也有bug，所以结论是工具只是辅助分析的作用，只有参照作用，并不能完全相信。最好是全都结合起来使用哈哈哈

工具使用教程：
>E-debug：编译好后把dll文件放到OD的插件public文件夹内，和一个EMap文件夹也是（下面工具生成）。
>CodeMake：提取所有易语言的`e/lib`核心库下的`.fne`文件，一个个都拖拽到这个工具里，然后会自动识别出核心库的所有命令，并把结果自动保存到同一路径下的生成文件，最后手动将所有结果保存到创建的一个叫EMap文件夹，把这个文件夹，放到OD的插件public文件夹内
>最后打开OD-->插件--》E-debug-->MainWindow

按钮事件特征码函数被VM，如何找到函数位置？？？
关键函数被VM掉，如何破解？？？
上层被VM的不用慌，可以尝试去找下层函数（被VM函数的里面的call）的特征码，任然能在内存中看到一些关键的数据。
易语言Ctrl+L定义变量。养成观察习惯，发现没有插件标注的call就是程序员自己写的函数，最好都进入观察一下

# 15 深入浅出易语言核心逆向(下) & 高级CM(VM)
遇到线程层层嵌套的算法题，而且防push窗口，动态显示的题目。怎么办？

之前我们学习过易语言体。
随便写一些按钮事件，发现在不同的消息处理下。最终都会来到易语言体，相当于一个必经之路。所以可以下断点在jmp易语言核心库等地方。然后跟踪。

遇到包含算法的复杂题目，比较难，类似于网络言验证，必须逆出原理才行，费时间。

语言按钮事件被VM了，而且跟踪其他函数内部也返回不到我们想要的特征码那个地方。我们可以换一种思路，去看上面的[ebp-4]的值是怎么传过来的。发现一个call ***.krnln_?BeginProcessEventCKrnlAppIAEKKHH2，这个函数的返回值eax被传入给了[ebp-4],即是【local.1】局部变量1.

F7跟踪这个函数发现，这个函数有很多个retn，不一定会走哪个返回才是按钮事件。因为这个函数是用来做消息传递的，比如点击了一下这个窗口就会走到其中一个retn，所以最好的方法就是在所有的retn下断点，根据最后EAX的返回值来排除法，通过点击按钮，确定最后应该在那个retn下断点才能获取到正确的按钮事件的函数地址！！！最后保存这最后需要的retn的特征码，就可以绕过VM了。

还有种方法执前面的课已经用过了哟，遇到假的按钮事件特征码，就是自己写个按钮事件的程序，然后提取哈函数头部上面那包括一堆int 3的特征给码，再去内存中搜素。

[《OD调试篇》OD快捷键。 - 不夜君 - 博客园](https://www.cnblogs.com/YiShen/p/9742872.html)