# this指针
C++把函数放在结构体里面和外面没区别，唯一的区别是放在结构体里面汇编会多传一个参数，参数就是当前对象的首地址
类和结构体没区别，都是在栈里
```asm
lea ecx,[ebp-4]
```

# 构造-析构函数
### 构造函数
构造函数和类名一样而且不需要定义返回值
C++可以重载构造函数，**重载函数**，函数一样，只不过参数不一样，名字可以一样
>构造函数特：
1、与类同名
2、没有返回值
3、创建对象的时候执行
4、主要用于初始化
5、可以有多个(最好有一个无参的),称为重载其他函数也可以重载6、编译器不要求必须提供斗

### 析构函数
析构函数和构造函数同名只不过前面加了个`~`
析构函数不允许**重载**
>析构函数的特点:
1、只能有一个析构函数，不能重载
2、不能带任何参数
3、不能带返回值
4、主要用于清理工作
5、编译器不要求必须提供

### 继承本质
代码的复制
父类的指针可以指向子类的对象，但是子类的指针
使用`:`符号继承
### 多层继承
```C
struct X
{
int a;
int b;
}
struct Y:X
{
int c;
int d;
}
struct Z:Y
{
int e;
int f;
}
sizeof(Z)==24
```

# 多重继承
不太推荐使用
```C
struct X
{
int a;
int b;
}
struct Y
{
int c;
int d;
}
struct Z:X,Y
{
int e;
int f;
}
```

# 虚函数
代码上只是多了个virtual

当使用对象的方式调用的时候是直接调用，和普通函数没区别


![[Pasted image 20240510162341.png]]
\_\_chkesp是检查堆栈平衡的
当用指针方式调用虚函数的时候采用的是间接调用

类里面的函数不占字节，而且发现虚函数virtual占用了4字节，而且在类里无论有几个虚函数只占一次，而且在对象的首地址存储，这个值保存的就是函数地址，也就是call edx里面的edx

其实这四个字节指向一个数组，这个数组存储所有的虚函数的地址，这就是设计思路，这就是虚函数表