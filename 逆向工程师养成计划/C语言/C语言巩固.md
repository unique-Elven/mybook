# 1 C语言的汇编表示
只有在程序运行的时候才能在右键-->Go To Disassembly看到反汇编代码

![[QQ截图20240309132717.png]]
![[QQ截图20240309132130.png]]

# 2 参数传递与返回值
画堆栈图，C语言使用堆栈传参，从右到左，返回值保存到EAX
![[Pasted image 20240309144348.png]]
可看下面的“变量与参数的内存布局”

# 3 变量
变量就是一个容器，变量类型确定变量的内存宽度，变量名确定内存编号

不从新编译，全局变量地址(内存编号)不会变
全局变量谁都可以改变
![[Pasted image 20240309144234.png]]

局部变量是函数内部申请的，如果函数没执行，那局部变量没有内存空间，堆栈分配，所以地址不固定，只能在函数内部使用。

#### 变量赋值
1）全局变量可以没有初始值而直接使用，系统默认初始值为0
2） 局部变量在使用前必须要赋值

例子： CE修改器，可以搜到绿色的局部变量的值，搜不到局部变量的值；如果要能搜到局部变量，那函数里要有死循环让函数一直执行状态才能查到。
# 4 变量与参数的内存布局
\[ebp - xx]一般都是局部变量

\[ebp + xx]一般都是参数
![[QQ截图20240309144021.png]]

# 5 函数嵌套调用的内存布局
C被调用的函数声明要放在调用函数的上方
![[Pasted image 20240309150252.png]]
VC6 生成的Debug版本软件有__chkesp函数用来检测堆栈是否平衡

# 06 整数类型
![[Pasted image 20240309154530.png]]
计算机是以补码的方式存储数据的，如何去看待这段数字，有符号还是无符号数看待是程序员的事情，计算机的本质就是-1=0xFFFFFFFF

有符号数可容纳的正数是无符号数的一半，因为另一半存负数

有符号数：当低宽度类型赋值给高宽度类型，高位的填充看符号位，符号位是什么就填充什么
无符号数： 原样填充，不看符号位

# 7 字符与字符串
ASCII表 0x7F=0~127
字符串以00结束
转义字符加`\`   格式化字符`%`
printf(''%6.2f'',x)  6是总共6个字符，小数占两个

# 8 中文字符
扩展ASCII 128-255

GB2312
就是把扩展ASCII修改了，每两个拓展ACII码的值拼凑成一个汉字；但是运到别的国家就会乱码

Unicode的出现就是为了解决这个问题

# 9 运算符与表达式
表达式最终结果，遵循最大的类型
char --> short --> int --> float --> double

++ 后 先运算 再自加
++ 前 先自加 再运算

# 10 分支语句
![[Pasted image 20240309162524.png]]

![[Pasted image 20240309162625.png]]

# 11 switch语句
![[Pasted image 20240309163128.png]]
5、Switch语句与if..else语句的区别:
<1>、switch结构只进行等值判断，而if..else可以进行区间判断
<2>、switch结构的执行效率远远高于if..else在分支条件比较多的情况下这种趋势愈发明显。

# 12 switch语句为什么