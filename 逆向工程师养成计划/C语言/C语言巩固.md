# 1 C语言的汇编表示
只有在程序运行的时候才能在右键-->Go To Disassembly看到反汇编代码

![[QQ截图20240309132717.png]]
![[QQ截图20240309132130.png]]

# 2 参数传递与返回值
画堆栈图，C语言使用堆栈传参，从右到左，返回值保存到EAX
![[Pasted image 20240309144348.png]]
可看下面的“变量与参数的内存布局”

# 3 变量
变量就是一个容器，变量类型确定变量的内存宽度，变量名确定内存编号

不从新编译，全局变量地址(内存编号)不会变
全局变量谁都可以改变
![[Pasted image 20240309144234.png]]

局部变量是函数内部申请的，如果函数没执行，那局部变量没有内存空间，堆栈分配，所以地址不固定，只能在函数内部使用。

#### 变量赋值
1）全局变量可以没有初始值而直接使用，系统默认初始值为0
2） 局部变量在使用前必须要赋值

例子： CE修改器，可以搜到绿色的局部变量的值，搜不到局部变量的值；如果要能搜到局部变量，那函数里要有死循环让函数一直执行状态才能查到。
# 4 变量与参数的内存布局
\[ebp - xx]一般都是局部变量

\[ebp + xx]一般都是参数
![[QQ截图20240309144021.png]]

# 5 函数嵌套调用的内存布局
C被调用的函数声明要放在调用函数的上方
![[Pasted image 20240309150252.png]]
VC6 生成的Debug版本软件有__chkesp函数用来检测堆栈是否平衡

# 06 整数类型
![[Pasted image 20240309154530.png]]
计算机是以补码的方式存储数据的，如何去看待这段数字，有符号还是无符号数看待是程序员的事情，计算机的本质就是-1=0xFFFFFFFF

有符号数可容纳的正数是无符号数的一半，因为另一半存负数

有符号数：当低宽度类型赋值给高宽度类型，高位的填充看符号位，符号位是什么就填充什么
无符号数： 原样填充，不看符号位

# 7 字符与字符串
ASCII表 0x7F=0~127
字符串以00结束
转义字符加`\`   格式化字符`%`
printf(''%6.2f'',x)  6是总共6个字符，小数占两个

# 8 中文字符
扩展ASCII 128-255

GB2312
就是把扩展ASCII修改了，每两个拓展ACII码的值拼凑成一个汉字；但是运到别的国家就会乱码

Unicode的出现就是为了解决这个问题

# 9 运算符与表达式
表达式最终结果，遵循最大的类型
char --> short --> int --> float --> double

++ 后 先运算 再自加
++ 前 先自加 再运算

# 10 分支语句
![[Pasted image 20240309162524.png]]

![[Pasted image 20240309162625.png]]

# 11 switch语句
![[Pasted image 20240309163128.png]]
5、Switch语句与if..else语句的区别:
<1>、switch结构只进行等值判断，而if..else可以进行区间判断
<2>、switch结构的执行效率远远高于if..else在分支条件比较多的情况下这种趋势愈发明显。

# 12 switch语句为什么高效

当判断变多的时候，计算跳转地址的设计非常巧妙，可以让判断代码变少，所以更高效，比如下面这段汇编代码，带入数据计算可以发现jmp是可计算的
内存中4010AF这张表存储了case的地址，而且不被case顺序所影响，就算case不连续，那没有的选项它就存default的地址
![[Pasted image 20240309164102.png]]

# 13 循环语句while，do...while，for

以下图片只是debug示例，不要生记,没有优化
![[Pasted image 20240309170156.png]]

![[Pasted image 20240309170231.png]]
![[Pasted image 20240309171049.png]]
for循环表达式都可以省略，如果第二个表达式不省略需要有值
for循环第1，3表达式可以使用逗号

# 14 数组
一个函数内堆栈默认提升的空间是0x40，当有一个4字节的变量就是0x44，两个4字节的变量是0x48，以此类推.......
因此定义数组的大小必须是常量表达式，不能是变量，不然不知道堆栈要提升多少
但是char类型的数组分配空间也是4字节的倍数（本机宽度），但是每一个元素之占1个字节

# 15多维数组
不论是多少维度的数组，再内存中都是线性存储没有区别
![[Pasted image 20240310122427.png]]

# 16 结构体

# 17 字节对齐
结构体按照最长的类型来字节对齐，所以有些浪费空间。
当对空间要求较高的时候，可以通过#pragma pack(n)来改变结构体成员的对齐方式
<1>   \#pragma pack(n)中n用来设定变量以n字节对齐方式,可以设定的值包括:1、2、4、8,VC编译器默认是8。
<2>若需取消强制对齐方式，则可用命令#pragma pack()。结束标志
[在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是-CSDN博客](https://blog.csdn.net/chengonghao/article/details/52160632)
![[Pasted image 20240310125630.png]]
1. 第一个数据成员放在offset为0的地方，对齐按照对齐系数和自身占用字节数中，二者比较小的那个进行对齐；

2. 在数据成员完成各自对齐以后，struct或者union本身也要进行对齐，对齐将按照对齐系数和struct或者union中最大数据成员长度中比较小的那个进行；

# 18 自动关机小程序
`按快捷键win+R，在弹出的命令输出窗口中输入"regedit"，找到: HKEY_CURRENT_USER\\Software\\Microsoft\\ Windows \\CurrentVersionI \\Run
`
新建完成后重命名，再右键单击新建的项目，选择“修改”，在弹出的对话框中设置软件路径，而后确定即可，如下图所示:
![[Pasted image 20240310130131.png]]

使用system函数执行DOS命令

![[Pasted image 20240310130116.png]]

# 19 结构体数组
指针类型的变量永远都是4字节、无论类型是什么，无论有几个`*`

1、不带`*`类型的变量，++或者--都是加1或者减1
2、带`*`类型的变量，++或者--新增(减少)的数量是去掉一个`*`后变量的宽度

1、指针类型的变量可以加、减一个整数，但不能乘或者除!
2、指针类型变量与其他整数相加或者相减时:
指针类型变量+N=指针类型变量+N`*`(去掉一个`*`后类型的宽度)
指针类型变量- N=指针类型变量-N`*`(去掉一个`*`后类型的宽度)

指针是无符号类型

# 20 预处理之宏定义

宏定义define可以成任何东西
宏更加节省空间，但是多次掉用，汇编代码就会赋值多少份
所以逻辑简单就用宏，复杂的用函数

# 21条件编译与文件包含
定义一个宏，然后在代码中添加条件，就可以随时取消一些测试代码被编译进去
```
指冷          用途
#define      定义宏
#undef       取消已定义的宏
#if          如果给定条件为真，则编译下面代码
#elif        如果前面的lif给定条件不为真，当前条件为真，则编译下面代码
#else        同else
#endif       结束一个#if......else条件编译块
#ifdef       如果宏已经定义，则编译下面代码
#ifndef      如果宏没有定义，则编译下面代码
#include     包含文件

```
尽量不要使用重复包含，不然终究会出问题，解决方案有条件编译或者前置声明