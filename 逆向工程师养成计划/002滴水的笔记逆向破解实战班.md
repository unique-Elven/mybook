# 11 脚本去花指令 & 易语言特征码应用
* 上节课的内容回顾
>1. main函数真的是最早执行的函数吗？(No) 全局变量在哪个函数进行初始化？(\_initterm)
>2. TLS--线程局部存储（为什么常常被用来进行反调试）(先于OEP运行，OD不停在OEP)
>3. 定位TLS的两个方法（插件StrongOD--但是插件在x64功能有限不是全部有效，PE结构--TLS目录AddressOfCallBacks）
>4. 指令变形，能修改EIP的指令，都能够实现花指令
>5. 俩个反调试函数：NtSetInformationThread、NtQueryInformationProcess

* 上节课的作业讲解继续补充某CTF--GIVE_A_TRY
NtQueryInformationProcess函数的第五个参数是`指向变量的指针，其中函数返回所请求信息的大小。 如果函数成功，则这是 _由 ProcessInformation_ 参数指向的缓冲区中写入的信息的大小 (如果缓冲区太小，则为成功接收信息) 所需的最小缓冲区大小。`所以返回是4。但是由于StrongOD有漏洞把返回变成了0，这道题就有利用到这一点。如下图，位置变成0，即使输入正确的注册码也提示不成功：
![[Pasted image 20240126183636.png]]
如果是正常的种子数应该是如下图这样的：
![[Pasted image 20240127114429.png]]
如过被反调试检测修改了这里的值，那就不好逆算法，但是还有一种方式，可以使用CE修改器来读取如下图：CE用好了也是神器，而且这玩意只是读取内存，不会被检测到。
![[Pasted image 20240127120029.png]]


在找到花指令的规则模板之后可以Ctrl+B直接二进制搜索匹配，还支持模糊匹配。类似于这样`E8 01 00 00 00 ?? ?? ?? ?? ?? C3`
当我们找到这样的规律后就可以不用一个个手动去，可以写脚本。
- 使用脚本去除反调试函数的花指令
OD有个运行脚本的插脚叫odbgscript在github上开源可下载。
编写脚本如下：
```
//判断是否找到
cmp $RESULT,0
//如果没找到就跳出结束
je exit
//如果找到就填充成NOP
mov [$RESULT],#90909090909090909090909090909090909090909090909090909090#
//从Eip的位置查找下一个特征码
find eip,#E80000000081042425000000C354686520666C616720626567696E7320776974682022666C61677B2200#


//判断是否找到
cmp $RESULT,0
//没找到就退出
je exit
//找到了就填充为NOP
mov [$RESULT],#909090909090909090909090909090909090909090909090909090909090909090909090909090909090#
//定义一个循环的标签，因为下面这个特征码不止一处，所以需要循环多次进行查找
loop:
	//从Eip的位置查找
	find eip,#E801000000??????????C3#
	//判断是否找到
	cmp $RESULT,0
	//如果找不到了就退出
	je exit
	//找到就填充为90
	mov [$RESULT],#9090909090909090909090#
//继续循环
jmp loop
exit:
MSG "花指令已去除完毕！\r\n Code by:Elven"
ret
```
右键--》运行脚本--》打开
右键--》脚本功能--》脚本运行窗口--》Tab键即可单步执行
更多脚本语法请参阅：ODbgScript中文说明v1.83
#### 易语言特征码应用篇
对付易语言程序最好从00401000开始搜索
1. 字符串比较函数特征码：test edx,3
	注意观察ECX和EDX对比字符串可能会在这里明文显示
		mov edx,dword ptr ss:[esp+0x4]
		mov ecx,dword ptr ss:[esp+0x8]
		test edx,edx
2. 按钮事件特征码：FF55FC5F5E
3. 易语言体特征码：FF25
	可以发现易语言也有类似微软的IAT表，所以也可以在这里全部下断点，肯定会用到的。
	![[Pasted image 20240126220507.png]]
如下图，易语言使用的是VC98linker微软（VC6.0）的链接器，链接器最大的作用是辅助调试，在VS项目的属性中--链接器--所选项可以控制生成的调试信息，当关闭时，OD都是jmp的一堆地址，根本看不懂，当打开OD就是显示符号（函数名）。因此我们可以对这部分链接器做修改，就能使易语言的程序在OD中显示出调试符号（API函数名）（挖坑，以后的内容，甚至在PE结构中也能找）
![[Pasted image 20240126221014.png]]
易语言--》失败点1--用的微软的VC链接器，失败点2--把何核心库的开发文档格式公开了
# 13 深入浅出易语言核心逆向(上)
课程回顾上面的特征码，核心必需要记住
* 先引入探究一下MFC程序的逆向
1. 建立一个MFC程序
2. 分析MFC程序按钮事件调用过程
3. 快速找到按钮点击后的代码位置
>建立时选--基于对话框--在静态库中使用MFC
>消息机制--是针对窗口GUI程序来说的，层层传递然后再到写的代码进行处理

程序拖入OD，运行后点击按钮，再暂停，Alt+K分析调用堆栈，如下图：越靠近上面的越是靠经最近执行的。
分析如下：
调用了AfxWinMain，这是MFC封装的，然后掉用了DoModel这是模态对话框，模式对话框时在对话框弹出后调用函数不会立即返回，而是等到对话框销毁后才会返回。（就弹出一个弹窗后，后面那个窗口就根本点不了了，这是由于UI线程阻塞，最上层弹窗有个死循环，一直等待用户消息）。但是我们附件里写的简单程序是非多模态的，弹框过后后面还能点能拖动。
[深入理解MFC消息循环和消息泵的原理\_mfc !afxgetapp()->pumpmessage()-CSDN博客](https://blog.csdn.net/u011555996/article/details/121755424)
然后应该清楚MFC的消息循环(::GetMessage,::PeekMessage)，消息泵(CWinThread::PumpMessage)和MFC的消息在窗口之间的路由是两件不同的事情。在MFC的应用程序中(应用程序类基于CWinThread继承)，必须要有一个消息循环，他的作用是从应用程序的消息队列中读取消息，并把它派送出去(::DispatchMessage)。而消息路由是指消息派送出去之后，系统(USER32.DLL)把消息投递到哪个窗口，以及以后消息在窗口之间的传递是怎样的。 
然后到user32往上传，遇到Afx的函数就是MFC的函数，AfxWndProc就是MFC接收消息的函数
![[Pasted image 20240128172558.png]]
![[Pasted image 20240128172609.png]]
额，好烦，我的程序OD看调用堆栈看不到和课程一样的流程，分开来了。why?
还好还有种在VS看的方法：执行调试--》调试--》窗口--》调用堆栈
* 易语言程序的逆向
1. 易语言链接器选项
2. 参考MFC程序的逆向方法分析易语言程序
3. 如何提取特征码

* 利用时钟扰乱按钮事件断点
1. 条件断点
2. 干掉时钟（不可取）

* PSUH窗体是怎么回事
1. 手动实现PUSH窗体
2. 插件的使用
