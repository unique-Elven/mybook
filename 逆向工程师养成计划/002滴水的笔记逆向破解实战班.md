# 11 脚本去花指令 & 易语言特征码应用
* 上节课的内容回顾
>1. main函数真的是最早执行的函数吗？(No) 全局变量在哪个函数进行初始化？(\_initterm)
>2. TLS--线程局部存储（为什么常常被用来进行反调试）(先于OEP运行，OD不停在OEP)
>3. 定位TLS的两个方法（插件StrongOD--但是插件在x64功能有限不是全部有效，PE结构--TLS目录AddressOfCallBacks）
>4. 指令变形，能修改EIP的指令，都能够实现花指令
>5. 俩个反调试函数：NtSetInformationThread、NtQueryInformationProcess

* 上节课的作业讲解继续补充
NtQueryInformationProcess函数的第五个参数是`指向变量的指针，其中函数返回所请求信息的大小。 如果函数成功，则这是 _由 ProcessInformation_ 参数指向的缓冲区中写入的信息的大小 (如果缓冲区太小，则为成功接收信息) 所需的最小缓冲区大小。`所以返回是4。但是由于StrongOD有漏洞把返回变成了0，这道题就有利用到这一点。
在找到花指令的规则模板之后可以Ctrl+B直接二进制搜索匹配，还支持模糊匹配。类似于这样`E8 01 00 00 00 ?? ?? ?? ?? ?? C3`
当我们找到这样的规律后就可以不用一个个手动去，可以写脚本。
OD有个运行脚本的插脚叫odbgscript在github上开源可下载。
编写脚本如下：
```
//判断是否找到
cmp $RESULT,0
//如果没找到就跳出结束
je exit
//如果找到就填充成NOP
mov [$RESULT],#90909090909090909090909090909090909090909090909090909090#
//从Eip的位置查找下一个特征码
find eip,#E80000000081042425000000C354686520666C616720626567696E7320776974682022666C61677B2200#


//判断是否找到
cmp $RESULT,0
//没找到就退出
je exit
//找到了就填充为NOP
mov [$RESULT],#909090909090909090909090909090909090909090909090909090909090909090909090909090909090#
//定义一个循环的标签，因为下面这个特征码不止一处，所以需要循环多次进行查找
loop:
	//从Eip的位置查找
	find eip,#E801000000??????????C3#
	//判断是否找到
	cmp $RESULT,0
	//如果找不到了就退出
	je exit
	//找到就填充为90
	mov [$RESULT],#9090909090909090909090#
//继续循环
jmp loop
exit:
MSG "花指令已去除完毕！\r\n Code by:Elven"
ret
```
右键--》运行脚本--》打开
右键--》脚本功能--》脚本运行窗口--》Tab键即可单步执行