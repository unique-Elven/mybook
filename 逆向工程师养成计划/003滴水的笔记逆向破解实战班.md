# 16 InlineHook补丁技术
* 认识Inline HOOK
其实在之前学习硬件HOOK的时候，我们已经自行了解过了。
1. HOOK的分类：Inline HOOK，APIHOOK,，IATHOOK，硬件HOOK
2. 什么是InlineHOOK
	>通过修改汇编代码从而实现修改程序执行流程
3. 易语言里的超级HOOK是什么？
	>是InlineHOOK的一种，可以对任意地址进行HOOK
	>易语言外挂作者常常称这种HOOK技术为超级HOOK


* 示例：利用InlineHOOK给程序添加信息框

OD分析易语言程序的时候，最好同时使用E-Debug_20.dll（包含CodeMake.exe），和E-Debug_302.dll两个插件。先使用E-Debug_20.dll，再点击使用E-Debug_302.dll！如果发现E-Debug_20.dll弹窗使用不了，那就在Alt+M内存窗口中查看找到，当前的内存地址开始(基址)和偏移的大小是多少，再回来填入弹框即可！

如下图，假如在下原本点击按钮只是会修改窗口标题的程序的按钮事件ff55fc5f5e下断点，我们需要通过lnlinehook技术，让它可以增加弹窗功能，F7跟踪得到如下图，我们想要在画红框的地方，进行jmp到一个全部为0的地方。
{为什么会有大片00的地方呢？原来PE文件有对齐机制}
![[Pasted image 20240204161429.png]]

![[Pasted image 20240204161440.png]]
```
//从右往左压入参数
int MessageBox(
  [in, optional] HWND    hWnd,
  [in, optional] LPCTSTR lpText,
  [in, optional] LPCTSTR lpCaption,
  [in]           UINT    uType
);
```
![[Pasted image 20240204161831.png]]
![[Pasted image 20240204180137.png]]
然后在那个地方开始编写自己的代码。最后要思考，怎么恢复被我们的jmp覆盖掉的原来的指令？其实在空白处的最后写回去再jmp回到原来的下面的地址就行。最后保存执行效果如下图：
![[Pasted image 20240204180220.png]]

课堂中，NCK老师还演示了`通用DLL注入器`的使用，是由易语言写的一个小工具，再拿个样例程序，看OD中找到个可以HOOK的地址，然后借助画眉(NCK)老师的`画眉HOOK模块`来编译个dll，最后借助`通用DLL注入器`选择dll--》选择注入进程--》远程线程注入--》开始注入。

* 上节课`小生帝王CM2无壳无VM`作业讲解
有了上面的知识铺垫，那么再分析这个程序，发现按钮事件后，看E-debug的注释call好像什么也没有做，那再哪里进行了关键比较呢？猜测有API被HOOK了，比较应该是再某个HOOK后的函数内进行的！

小tips：可以使用火绒剑或者pchunter等工具查看`钩子扫描`
![[Pasted image 20240204214437.png]]
还有字节集的概念，在内存中是个结构体，包含（编号，数据大小几个字节，几个字节的数据）
![[Pasted image 20240204223804.png]]


>如下分析：
HOOK（有两个，前面那个在内部比较了两个内部的字符串不相等就跳过了一大段比较，后面那个内部比较了两个内部的字符串相等才是继续判断对比注册码）（其实就是自我判断是否为第一个call，如果是就不进行比较）-->创建线程--》用线程判断注册码
第一步，下断点按钮事件
第二步，发现按钮事件内部都只有读取组件属性和设置组件属性，没有自定义函数吗？
第三步，跟踪其中一个设置组件属性的call，F7后一直F8
第四步，F8到一个地方，很类似于上面dll注入使用的HOOK，是个jmp
第五步，跟踪这个jmp，发现HOOK后是创建线程
第六步，跟踪这个线程，就可以来到算法处
第七步。借助E-debug分析算法。
![[Pasted image 20240204214447.png]]

![[Pasted image 20240204214454.png]]

![[Pasted image 20240204214507.png]]

![[Pasted image 20240204214513.png]]

![[Pasted image 20240204214519.png]]

![[Pasted image 20240204214527.png]]

![[Pasted image 20240204214540.png]]

![[Pasted image 20240205104832.png]]

最后跟踪算法到最后！nop一些跳转，成功实现破解，而且逆出注册码：`牧牛论坛      bbs.92fzb.com`
最后留下的作业，用lilineHook技术实现音乐的播放，关键的API就是`mciSendString`
但是我搜索00,发现0047DFCD的区段00的位置不够，到内存窗口一看才发现程序竟然多了个.test段，好那就跳到这里来004BB081吧，最后开始编写成功了，如下图
![[Pasted image 20240205115113.png]]

![[Pasted image 20240205115120.png]]

# 17 上节课堂回顾 & 初识浮点寄存器
* 课程回顾
1. 什么是InlineHook(就是修改汇编代码的hook)
2. Inlinehook的原理是什么（jmp出去再回来）
3. 利用 易语言Inlinehook给程序添加一个打开网页的功能(上节课翻车了)
4. 超级HOOK的应用，挂钩易语言核心库
5. 如何快速找到当前程序的HOOK位置（火绒剑等）

* 上节课翻车补充
	>昨天，发现注入后，点击dll产生的按钮之后会卡死，没反应，看附件代码，发现，就是易语言的消息循环问题，dll有`载入(窗口1，，真)`，这里面的真就是是否为模态对话框，是真就为模态对话框，所以程序会阻塞，所以要写假！但是直接改假之后发现再注入成功过后dll程序又一闪而过。
	>![[Pasted image 20240205173258.png]]
	>所以最好的接解决办法就是在dll创建一个线程，再手动写消息循环就可以了，才能接收到用户点击消息，这是易语言，C没这么麻烦，底层封装问题，如下图
	>![[Pasted image 20240205171832.png]]
	>总结：易语言在线程里面创建的窗口，消息循环需要自己写，不然窗口就一闪而过





 
* 分析上节作业程序是何时进行HOOK的
	>1. 可以在火绒剑直接扫描到HOOK的位置
	>2. 按钮事件下断点也能跟踪到jmp
	>但是我们发现提前在那个位置下断点，竟然不是jmp。它是在程序的执行过程中给变成了jmp的HOOK
	
	思考？这是什么原因造成的呢？猜测，在内存段中程序多个.test段。或许就是在这里做的手脚。。。
	要知道究竟是怎么回事，还是需要知道下面这个知识的铺垫，类比一下豁然开朗！



* DLL永久注入技术（文件注入）-----------------------------感觉非常重要！
![[Pasted image 20240205173553.png]]

原理其实就是把整个PE文件贴进去了，而且优先于OEP先执行，有点像是壳的原理

对比两个程序的区别：
![[Pasted image 20240205175453.png]]

![[Pasted image 20240205175459.png]]

![[Pasted image 20240205175505.png]]

emmm~发现这个差别后，就有一种很扫的思路，就是修改OEP，打开CFF Explorer--》找到可选头部--》修改AddressOfEntryPoint的值（0017D000-->0005F49D）-->再执行程序，发现就会直接从原来未被注入的程序的OEP开始执行了，但是其实代码还在PE文件中的，只是不执行了，这是一种巧妙的绕过思路呀！

* 永久注入后的PE文件提取
思考？有没有什么办法可以提出PE文件里面被永久注入的dll呢?
其实很简单啦，如下图而已。
在单步F8跟踪运行到.gdata节里的代码指令的时候，在`0057D0D7`的位置--》右键--》数据窗口中跟随--》内存地址--》由于用的是取地址的中括号（指针）--》所以在下面的内存窗口开始应该选中四个字节右键--》数据窗口中跟随DWORD（这个是非常重要的）

就能看到一个以MZ开头的数据，这难道不是我们熟悉的PE文件结构吗？直接开始拉到选中按Shfit，拉到最后面全选，然后复制保存到类似010Editer的软件保存成dll

发现把这段扒拉出来的dll，用dll注入器注入到正常的作业中，一样能用，我这里连大小都一样（字节有细微差别哈哈复制的原因）
![[Pasted image 20240205204007.png]]

* C语言手动编写dll,HOOK任意地址播放音乐
由于上节课课后我是直接汇编改了哈哈哈哈
这节课学习一下C语言写的！
在属性中按照事前所学设置，调试--》命令--》填入待HOOK的exe程序路径
示例exe程序直接LoadlibraryA("Inlinehook.dll")